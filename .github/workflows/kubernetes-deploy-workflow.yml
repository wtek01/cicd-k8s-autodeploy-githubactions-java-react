# .github/workflows/kubernetes-deploy-workflow.yml
name: Deploy to Kubernetes

on:
  push:
    branches:
      - main
    paths:
      - "infrastructure/k8s/**"
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to deploy"
        required: true
        default: "main"
  workflow_run:
    workflows: ["Build and Publish"]
    types:
      - completed

env:
  REGISTRY: docker.io
  FRONTEND_IMAGE_NAME: wtek01/frontend
  FRONTEND_IMAGE_TAG: 0.3.1
  USER_SERVICE_IMAGE_NAME: wtek01/user-service
  USER_SERVICE_IMAGE_TAG: 0.3.0
  ORDER_SERVICE_IMAGE_NAME: wtek01/order-service
  ORDER_SERVICE_IMAGE_TAG: 0.3.0
  DOCKERHUB_USERNAME: wtek01
  # Changed to never skip verification on any branch to ensure proper testing
  SKIP_DOCKER_VERIFICATION: "false"

jobs:
  deploy-k8s:
    runs-on: self-hosted
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.inputs.branch || github.ref_name }}

      - name: Get branch name
        id: get-branch
        run: |
          if ('${{ github.event.inputs.branch }}') {
            $branch = '${{ github.event.inputs.branch }}'
          } else {
            $branch = '${{ github.ref_name }}'
          }
          echo "branch=$branch" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          echo "Using branch: $branch"

      - name: Set deployment environment
        id: set-env
        run: |
          $branch = '${{ steps.get-branch.outputs.branch }}'
          echo "Branch: $branch"

          # Determine environment and namespace based on branch
          if ($branch -eq 'main') {
            $env = 'production'
            $namespace = 'microservices'
            $suffix = ''
          } elseif ($branch -like 'feature/*') {
            $env = 'development'
            $branchName = $branch.Substring(8).ToLower()
            $namespace = "feature-${branchName}".Replace('/', '-')
            $suffix = "-$($branch.Replace('/', '-'))"
          } else {
            $env = 'staging'
            $namespace = 'microservices-staging'
            $suffix = '-staging'
          }

          echo "environment=$env" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          echo "namespace=$namespace" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          echo "suffix=$suffix" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

          echo "Environment: $env"
          echo "Namespace: $namespace"
          echo "Deployment suffix: $suffix"

      - name: Wait for Docker Hub to process images
        run: |
          Write-Host "Waiting 15 seconds for Docker Hub to process images..."
          Start-Sleep -Seconds 15

      - name: Verify Docker images exist
        id: verify-docker-images
        run: |
          $branch = '${{ steps.get-branch.outputs.branch }}'

          # Always verify images to prevent untested code from reaching any environment
          Write-Host "Verifying Docker images for $branch branch"

          $username = "${{ env.DOCKERHUB_USERNAME }}"
          $password = "${{ secrets.DOCKERHUB_TOKEN }}"

          # Determine which images to verify based on branch
          if ($branch -like "feature/*") {
            # For feature branches, we need to verify the feature-specific images
            # Extract the feature branch name for dynamic image tags
            $featureName = $branch.Substring(8).ToLower()
            
            # The build workflow should tag images for feature branches as {original-tag}-{feature-name}
            # For example: 0.3.1-frontend-k8s-deployment 
            $frontendImageTag = "${{ env.FRONTEND_IMAGE_TAG }}-$featureName"
            $userServiceImageTag = "${{ env.USER_SERVICE_IMAGE_TAG }}-$featureName"
            $orderServiceImageTag = "${{ env.ORDER_SERVICE_IMAGE_TAG }}-$featureName"
          } else {
            # For main/production or other branches, use the standard tags
            $frontendImageTag = "${{ env.FRONTEND_IMAGE_TAG }}"
            $userServiceImageTag = "${{ env.USER_SERVICE_IMAGE_TAG }}"
            $orderServiceImageTag = "${{ env.ORDER_SERVICE_IMAGE_TAG }}"
          }

          $frontendImage = "${{ env.FRONTEND_IMAGE_NAME }}:$frontendImageTag"
          $userServiceImage = "${{ env.USER_SERVICE_IMAGE_NAME }}:$userServiceImageTag"
          $orderServiceImage = "${{ env.ORDER_SERVICE_IMAGE_NAME }}:$orderServiceImageTag"

          Write-Host "Checking images:"
          Write-Host "- $frontendImage"
          Write-Host "- $userServiceImage"
          Write-Host "- $orderServiceImage"

          # Alternative approach - use docker CLI which already has auth from docker login
          function Check-DockerImageCLI {
            param (
              [string]$image
            )
            
            try {
              # Login to Docker Hub
              docker login -u "$username" -p "$password" docker.io
              
              # Try to pull the image manifest
              $result = docker manifest inspect $image 2>&1
              if ($LASTEXITCODE -eq 0) {
                Write-Host "✅ Image $image exists in Docker Hub"
                return $true
              } else {
                Write-Host "❌ Image $image not found in Docker Hub: $result"
                return $false
              }
            } catch {
              Write-Host "❌ Error checking image $image`: $($_.Exception.Message)"
              return $false
            }
          }

          Write-Host "Using Docker CLI to verify images..."
          $frontendExists = Check-DockerImageCLI -image $frontendImage
          $userServiceExists = Check-DockerImageCLI -image $userServiceImage
          $orderServiceExists = Check-DockerImageCLI -image $orderServiceImage

          if (-not ($frontendExists -and $userServiceExists -and $orderServiceExists)) {
            Write-Host "One or more required Docker images not found in Docker Hub."
            Write-Host "Waiting additional 30 seconds and retrying..."
            Start-Sleep -Seconds 30
            
            $frontendExists = Check-DockerImageCLI -image $frontendImage
            $userServiceExists = Check-DockerImageCLI -image $userServiceImage
            $orderServiceExists = Check-DockerImageCLI -image $orderServiceImage
            
            if (-not ($frontendExists -and $userServiceExists -and $orderServiceExists)) {
              Write-Error "Required Docker images not available. Deployment failed."
              Write-Host "Please make sure you have run the CI workflow to build and push the required images before deploying."
              Write-Host "For feature branches, images should be tagged with the feature branch name."
              exit 1
            }
          }

          # Set the verified image tags as outputs for use in deployment
          echo "frontend_image_tag=$frontendImageTag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          echo "user_service_image_tag=$userServiceImageTag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          echo "order_service_image_tag=$orderServiceImageTag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

          Write-Host "All Docker images verified successfully!"

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure kubeconfig
        run: |
          $kubeconfig = '${{ secrets.KUBE_CONFIG }}'
          $kubeconfigPath = "$env:USERPROFILE\.kube\config"

          # Ensure directory exists
          if (-not (Test-Path "$env:USERPROFILE\.kube")) {
            New-Item -ItemType Directory -Path "$env:USERPROFILE\.kube" -Force
          }

          # Write kubeconfig
          Set-Content -Path $kubeconfigPath -Value $kubeconfig

          # Test connection
          kubectl get nodes

      # Try to deploy using the updated manifests from the repository
      - name: Create namespace if not exists
        run: |
          $namespace = '${{ steps.set-env.outputs.namespace }}'
          Write-Host "Creating namespace: $namespace (if it doesn't exist)"
          kubectl create namespace $namespace --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to Kubernetes
        run: |
          $namespace = '${{ steps.set-env.outputs.namespace }}'
          $suffix = '${{ steps.set-env.outputs.suffix }}'
          $branch = '${{ steps.get-branch.outputs.branch }}'

          # Use the verified image tags from the previous step
          $frontendImageTag = '${{ steps.verify-docker-images.outputs.frontend_image_tag }}'
          $userServiceImageTag = '${{ steps.verify-docker-images.outputs.user_service_image_tag }}'
          $orderServiceImageTag = '${{ steps.verify-docker-images.outputs.order_service_image_tag }}'

          Write-Host "Deploying to Kubernetes namespace: $namespace with suffix: $suffix"
          Write-Host "Using verified image tags:"
          Write-Host "- Frontend: $frontendImageTag"
          Write-Host "- User Service: $userServiceImageTag"
          Write-Host "- Order Service: $orderServiceImageTag"

          # First, check if we have a kustomize overlay for this branch
          if (Test-Path "infrastructure/k8s/overlays/$branch") {
            Write-Host "Found kustomize overlay for branch $branch"
            kubectl apply -k infrastructure/k8s/overlays/$branch -n $namespace
          } else {
            Write-Host "No kustomize overlay found, applying manifests directly"
            
            # Replace variables in all manifest files before applying
            $files = Get-ChildItem -Path infrastructure/k8s -Filter "*.yml"
            foreach ($file in $files) {
              Write-Host "Processing $($file.Name)..."
              $content = Get-Content $file.FullName -Raw
              
              # Replace namespace placeholder
              if ($content -match '\${NAMESPACE}') {
                Write-Host "  Replacing \${NAMESPACE} with $namespace in $($file.Name)"
                $content = $content.Replace('${NAMESPACE}', $namespace)
              }
              
              # Replace version placeholder in frontend-deployment.yml
              if ($file.Name -eq "frontend-deployment.yml" -and $content -match '\${VERSION}') {
                Write-Host "  Replacing \${VERSION} with $frontendImageTag in $($file.Name)"
                $content = $content.Replace('${VERSION}', $frontendImageTag)
                
                # If we have a suffix, also update the ConfigMap reference
                if ($suffix) {
                  Write-Host "  Updating configMapRef for frontend-config to frontend-config$suffix in $($file.Name)"
                  $content = $content -replace "name: frontend-config", "name: frontend-config$suffix"
                }

                # For feature branches, update the name to avoid conflicts with main deployments
                if ($branch -like 'feature/*') {
                  Write-Host "  Updating frontend service names with suffix: $suffix in $($file.Name)"
                  $content = $content -replace "name: frontend(\s|$)", "name: frontend$suffix`$1"
                  $content = $content -replace "app: frontend(\s|$)", "app: frontend$suffix`$1"
                }
              }
              
              # Update user-service image
              if ($file.Name -eq "user-service.yml" -and $content -match 'image: wtek01/user-service:') {
                Write-Host "  Updating user-service image to use tag: $userServiceImageTag"
                $content = $content -replace "image: wtek01/user-service:[^\"'\s]+", "image: wtek01/user-service:$userServiceImageTag"
              }
              
              # Update order-service image
              if ($file.Name -eq "order-service.yml" -and $content -match 'image: wtek01/order-service:') {
                Write-Host "  Updating order-service image to use tag: $orderServiceImageTag"
                $content = $content -replace "image: wtek01/order-service:[^\"'\s]+", "image: wtek01/order-service:$orderServiceImageTag"
              }
              
              # Replace other variables if they exist
              if ($content -match '\${FRONTEND_HOST}') {
                if ($branch -eq 'main') {
                  $frontendHost = 'todoapp.localdev.me'
                } else {
                  $branchName = $branch.Replace('/', '-')
                  $frontendHost = "$branchName.todoapp.localdev.me"
                }
                Write-Host "  Replacing \${FRONTEND_HOST} with $frontendHost in $($file.Name)"
                $content = $content.Replace('${FRONTEND_HOST}', $frontendHost)
              }
              
              if ($content -match '\${API_HOST}') {
                if ($branch -eq 'main') {
                  $apiHost = 'api.todoapp.localdev.me'
                } else {
                  $branchName = $branch.Replace('/', '-')
                  $apiHost = "$branchName-api.todoapp.localdev.me"
                }
                Write-Host "  Replacing \${API_HOST} with $apiHost in $($file.Name)"
                $content = $content.Replace('${API_HOST}', $apiHost)
              }
              
              if ($content -match '\${FRONTEND_SERVICE}') {
                $frontendService = "frontend$suffix"
                Write-Host "  Replacing \${FRONTEND_SERVICE} with $frontendService in $($file.Name)"
                $content = $content.Replace('${FRONTEND_SERVICE}', $frontendService)
              }
              
              if ($content -match '\${USER_SERVICE}') {
                $userService = "user-service$suffix"
                Write-Host "  Replacing \${USER_SERVICE} with $userService in $($file.Name)"
                $content = $content.Replace('${USER_SERVICE}', $userService)
              }
              
              if ($content -match '\${ORDER_SERVICE}') {
                $orderService = "order-service$suffix"
                Write-Host "  Replacing \${ORDER_SERVICE} with $orderService in $($file.Name)"
                $content = $content.Replace('${ORDER_SERVICE}', $orderService)
              }
              
              # Write the processed content to a temporary file
              $tempFile = "temp-$($file.Name)"
              Set-Content -Path $tempFile -Value $content
              
              # Apply the processed manifest
              Write-Host "Applying $tempFile to namespace $namespace"
              kubectl apply -f $tempFile -n $namespace
              
              # Clean up the temporary file
              Remove-Item $tempFile
            }
          }

          Write-Host "Kubernetes manifests deployed successfully!"

      # Create the frontend ConfigMap directly with kubectl
      - name: Create Frontend ConfigMap
        run: |
          $namespace = '${{ steps.set-env.outputs.namespace }}'
          $suffix = '${{ steps.set-env.outputs.suffix }}'
          $branch = '${{ steps.get-branch.outputs.branch }}'

          # Set the API_BASE_URL based on branch
          if ($branch -eq 'main') {
            $apiHost = 'api.todoapp.localdev.me'
          } else {
            $branchName = $branch.Replace('/', '-')
            $apiHost = "$branchName-api.todoapp.localdev.me"
          }

          $configMapName = "frontend-config$suffix"

          # Check if ConfigMap exists and delete it
          kubectl get configmap $configMapName -n $namespace --ignore-not-found -o name | ForEach-Object {
            Write-Host "Deleting existing ConfigMap $configMapName in namespace $namespace"
            kubectl delete configmap $configMapName -n $namespace
          }

          Write-Host "Creating ConfigMap $configMapName in namespace $namespace"
          # Create the ConfigMap with the necessary configuration
          kubectl create configmap $configMapName `
            --from-literal=VITE_API_BASE_URL="https://$apiHost" `
            --from-literal=VITE_USER_SERVICE_URL="https://$apiHost/api/users" `
            --from-literal=VITE_ORDER_SERVICE_URL="https://$apiHost/api/orders" `
            --namespace $namespace `
            --dry-run=client -o yaml | kubectl apply -f -

          # Add labels to the ConfigMap to match selectors
          Write-Host "Adding app=frontend$suffix label to ConfigMap $configMapName in namespace $namespace"
          kubectl label configmap $configMapName app=frontend$suffix -n $namespace --overwrite

      - name: Force redeploy services
        run: |
          $namespace = '${{ steps.set-env.outputs.namespace }}'
          $suffix = '${{ steps.set-env.outputs.suffix }}'

          Write-Host "Force redeploying services in namespace: $namespace with suffix: $suffix"

          # Restart User Service
          try {
            Write-Host "Restarting user-service$suffix..."
            kubectl rollout restart deployment user-service$suffix -n $namespace
            Write-Host "✅ user-service$suffix restarted successfully"
          } catch {
            Write-Host "⚠️ Warning: Failed to restart user-service$suffix: $_"
          }

          # Restart Order Service
          try {
            Write-Host "Restarting order-service$suffix..."
            kubectl rollout restart deployment order-service$suffix -n $namespace
            Write-Host "✅ order-service$suffix restarted successfully"
          } catch {
            Write-Host "⚠️ Warning: Failed to restart order-service$suffix: $_"
          }

          # Restart Frontend
          try {
            Write-Host "Restarting frontend$suffix..."
            kubectl rollout restart deployment frontend$suffix -n $namespace
            Write-Host "✅ frontend$suffix restarted successfully"
          } catch {
            Write-Host "⚠️ Warning: Failed to restart frontend$suffix: $_"
          }

          Write-Host "Waiting for services to stabilize..."
          Start-Sleep -Seconds 10

          # Check pod status
          kubectl get pods -n $namespace

      - name: Check deployment status
        run: |
          $namespace = '${{ steps.set-env.outputs.namespace }}'
          $suffix = '${{ steps.set-env.outputs.suffix }}'

          Write-Host "Checking deployment status in namespace: $namespace"

          # Get deployments status
          kubectl get deployments -n $namespace

          # Get services
          kubectl get services -n $namespace

          # Get ingress
          kubectl get ingress -n $namespace

          # Get pods details
          kubectl get pods -n $namespace -o wide

          # Check specific deployments
          $frontendDeployment = "frontend$suffix"
          $userServiceDeployment = "user-service$suffix"
          $orderServiceDeployment = "order-service$suffix"

          Write-Host "Detailed status for $frontendDeployment:"
          kubectl describe deployment $frontendDeployment -n $namespace

          Write-Host "Detailed status for $userServiceDeployment:"
          kubectl describe deployment $userServiceDeployment -n $namespace

          Write-Host "Detailed status for $orderServiceDeployment:"
          kubectl describe deployment $orderServiceDeployment -n $namespace

          Write-Host "Deployment check completed."
